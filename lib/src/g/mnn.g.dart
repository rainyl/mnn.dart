// Copyright (c) 2025, rainyl.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:mnn/mnn.dart')
library;

import 'dart:ffi' as ffi;
import '' as self;

/// @brief Creates a new auto timer instance
/// @param line Source code line number (for debugging)
/// @param func Function name (for debugging)
/// @return Pointer to the newly created auto timer
@ffi.Native<mnn_auto_time_t Function(ffi.Int, ffi.Pointer<ffi.Char>)>()
external mnn_auto_time_t mnn_auto_time_create(
  int line,
  ffi.Pointer<ffi.Char> func,
);

/// @brief Destroys an auto timer instance
/// @param auto_time Auto timer instance to destroy
@ffi.Native<ffi.Void Function(mnn_auto_time_t)>()
external void mnn_auto_time_destroy(
  mnn_auto_time_t auto_time,
);

/// @brief Get MNN version
/// @return Version string
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> mnn_get_version();

/// @brief Get biz code from interpreter
/// @param self Interpreter instance
/// @return Biz code string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_biz_code(
  mnn_interpreter_t self,
);

/// @brief Create interpreter from buffer
/// @param buffer Model data buffer
/// @param size Buffer size
/// @param callback Callback function to be called after creation
/// @return Interpreter instance or NULL if failed
@ffi.Native<
    mnn_interpreter_t Function(
        ffi.Pointer<ffi.Void>, ffi.Size, mnn_callback_0)>()
external mnn_interpreter_t mnn_interpreter_create_from_buffer(
  ffi.Pointer<ffi.Void> buffer,
  int size,
  mnn_callback_0 callback,
);

/// @brief Create interpreter from file
/// @param file_path Path to model file
/// @param callback Callback function to be called after creation
/// @return Interpreter instance or NULL if failed
@ffi.Native<mnn_interpreter_t Function(ffi.Pointer<ffi.Char>, mnn_callback_0)>()
external mnn_interpreter_t mnn_interpreter_create_from_file(
  ffi.Pointer<ffi.Char> file_path,
  mnn_callback_0 callback,
);

/// @brief Create runtime info
/// @param configs Schedule config array
/// @param count Config count
/// @return Runtime info instance
@ffi.Native<
    mnn_runtime_info_t Function(ffi.Pointer<mnn_schedule_config_t>, ffi.Size)>()
external mnn_runtime_info_t mnn_interpreter_create_runtime(
  ffi.Pointer<mnn_schedule_config_t> configs,
  int count,
);

/// @brief Create session with config
/// @param self Interpreter instance
/// @param config Schedule config
/// @param callback Callback function to be called after creation
/// @return Session instance or NULL if failed
@ffi.Native<
    mnn_session_t Function(mnn_interpreter_t,
        ffi.Pointer<mnn_schedule_config_t>, mnn_callback_0)>()
external mnn_session_t mnn_interpreter_create_session(
  mnn_interpreter_t self,
  ffi.Pointer<mnn_schedule_config_t> config,
  mnn_callback_0 callback,
);

/// @brief Create session with runtime info
/// @param self Interpreter instance
/// @param config Schedule config
/// @param runtime Runtime info
/// @param callback Callback function to be called after creation
/// @return Session instance or NULL if failed
@ffi.Native<
    mnn_session_t Function(
        mnn_interpreter_t,
        ffi.Pointer<mnn_schedule_config_t>,
        mnn_runtime_info_t,
        mnn_callback_0)>()
external mnn_session_t mnn_interpreter_create_session_with_runtime(
  mnn_interpreter_t self,
  ffi.Pointer<mnn_schedule_config_t> config,
  mnn_runtime_info_t runtime,
  mnn_callback_0 callback,
);

/// @brief Destroy interpreter instance
/// @param self Interpreter to destroy
@ffi.Native<ffi.Void Function(mnn_interpreter_t)>()
external void mnn_interpreter_destroy(
  mnn_interpreter_t self,
);

/// @brief Get backend type
/// @param self Interpreter instance
/// @param session Session
/// @return Backend type
@ffi.Native<
    mnn_backend_t Function(mnn_interpreter_t, mnn_session_t, mnn_tensor_t)>()
external mnn_backend_t mnn_interpreter_get_backend(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_tensor_t tensor,
);

/// @brief Get model buffer
/// @param self Interpreter instance
/// @param buffer Output parameter to receive pointer to model data
/// @return Size of model data in bytes, or 0 if failed
@ffi.Native<
    ffi.Size Function(mnn_interpreter_t, ffi.Pointer<ffi.Pointer<ffi.Void>>)>()
external int mnn_interpreter_get_model_buffer(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Pointer<ffi.Void>> buffer,
);

/// @brief Get model version
/// @param self Interpreter instance
/// @return Version string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_get_model_version(
  mnn_interpreter_t self,
);

/// @brief Get session info
/// @param self Interpreter instance
/// @param session Session
/// @param info Output parameter for session info
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t, ffi.Int,
        ffi.Pointer<ffi.Void>)>(symbol: 'mnn_interpreter_get_session_info')
external int _mnn_interpreter_get_session_info(
  mnn_interpreter_t self,
  mnn_session_t session,
  int session_info_code,
  ffi.Pointer<ffi.Void> info,
);

ErrorCode mnn_interpreter_get_session_info(
  mnn_interpreter_t self,
  mnn_session_t session,
  int session_info_code,
  ffi.Pointer<ffi.Void> info,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_info(
      self,
      session,
      session_info_code,
      info,
    ));

/// @brief Get input tensor by name
/// @param self Interpreter instance
/// @param session Session
/// @param name Tensor name (NULL for first input)
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        mnn_interpreter_t, mnn_session_t, ffi.Pointer<ffi.Char>)>()
external mnn_tensor_t mnn_interpreter_get_session_input(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Char> name,
);

/// @brief Get all input tensors from session
/// @param self Interpreter instance
/// @param session Session
/// @param tensors Output parameter for tensor array
/// @param count Output parameter for tensor count
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(
        mnn_interpreter_t,
        mnn_session_t,
        ffi.Pointer<ffi.Pointer<mnn_tensor_t>>,
        ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
        ffi.Pointer<ffi.Size>)>(symbol: 'mnn_interpreter_get_session_input_all')
external int _mnn_interpreter_get_session_input_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
);

ErrorCode mnn_interpreter_get_session_input_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_input_all(
      self,
      session,
      tensors,
      names,
      count,
    ));

/// @brief Get output tensor by name
/// @param self Interpreter instance
/// @param session Session
/// @param name Tensor name (NULL for first output)
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        mnn_interpreter_t, mnn_session_t, ffi.Pointer<ffi.Char>)>()
external mnn_tensor_t mnn_interpreter_get_session_output(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Char> name,
);

/// @brief Get all output tensors from session
/// @param self Interpreter instance
/// @param session Session
/// @param tensors Output parameter for tensor array
/// @param count Output parameter for tensor count
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(
            mnn_interpreter_t,
            mnn_session_t,
            ffi.Pointer<ffi.Pointer<mnn_tensor_t>>,
            ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
            ffi.Pointer<ffi.Size>)>(
    symbol: 'mnn_interpreter_get_session_output_all')
external int _mnn_interpreter_get_session_output_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
);

ErrorCode mnn_interpreter_get_session_output_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_output_all(
      self,
      session,
      tensors,
      names,
      count,
    ));

/// @brief Release model
/// @param self Interpreter instance
@ffi.Native<ffi.Void Function(mnn_interpreter_t)>()
external void mnn_interpreter_release_model(
  mnn_interpreter_t self,
);

/// @brief Release session
/// @param self Interpreter instance
/// @param session Session to release
/// @param callback Callback function to be called after release
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_release_session')
external int _mnn_interpreter_release_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_release_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_release_session(
      self,
      session,
      callback,
    ));

/// @brief Resize session
/// @param self Interpreter instance
/// @param session Session to resize
/// @param callback Callback function to be called after resize
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_resize_session')
external int _mnn_interpreter_resize_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_resize_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_session(
      self,
      session,
      callback,
    ));

/// @brief Resize tensor
/// @param tensor Tensor to resize
/// @param dims New dimensions array
/// @param dim_count Dimension count
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_tensor_t,
        ffi.Pointer<ffi.Int>, ffi.Int)>(symbol: 'mnn_interpreter_resize_tensor')
external int _mnn_interpreter_resize_tensor(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  ffi.Pointer<ffi.Int> dims,
  int dim_count,
);

ErrorCode mnn_interpreter_resize_tensor(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  ffi.Pointer<ffi.Int> dims,
  int dim_count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_tensor(
      self,
      tensor,
      dims,
      dim_count,
    ));

@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_tensor_t, ffi.Int, ffi.Int,
        ffi.Int, ffi.Int)>(symbol: 'mnn_interpreter_resize_tensor_1')
external int _mnn_interpreter_resize_tensor_1(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  int batch,
  int channel,
  int height,
  int width,
);

ErrorCode mnn_interpreter_resize_tensor_1(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  int batch,
  int channel,
  int height,
  int width,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_tensor_1(
      self,
      tensor,
      batch,
      channel,
      height,
      width,
    ));

/// @brief Run session
/// @param self Interpreter instance
/// @param session Session to run
/// @param callback Callback function to be called after run
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_run_session')
external int _mnn_interpreter_run_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_run_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_run_session(
      self,
      session,
      callback,
    ));

/// @brief Set cache file for interpreter
/// @param self Interpreter instance
/// @param cache_file Cache file path
/// @param key_size Key size
@ffi.Native<
    ffi.Void Function(mnn_interpreter_t, ffi.Pointer<ffi.Char>, ffi.Size)>()
external void mnn_interpreter_set_cache_file(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Char> cache_file,
  int key_size,
);

/// @brief Set external file for interpreter
/// @param self Interpreter instance
/// @param file External file path
/// @param flag Flag value
@ffi.Native<
    ffi.Void Function(mnn_interpreter_t, ffi.Pointer<ffi.Char>, ffi.Size)>()
external void mnn_interpreter_set_external_file(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Char> file,
  int flag,
);

/// @brief Set session hint
/// @param self Interpreter instance
/// @param mode Hint mode
/// @param value Hint value
@ffi.Native<ffi.Void Function(mnn_interpreter_t, ffi.Int, ffi.Int)>()
external void mnn_interpreter_set_session_hint(
  mnn_interpreter_t self,
  int mode,
  int value,
);

/// @brief Set session mode
/// @param self Interpreter instance
/// @param mode Session mode
@ffi.Native<ffi.Void Function(mnn_interpreter_t, ffi.Int)>()
external void mnn_interpreter_set_session_mode(
  mnn_interpreter_t self,
  int mode,
);

/// @brief Update cache file
/// @param self Interpreter instance
/// @param session Session
/// @param flag Flag value
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t, ffi.Int)>(
    symbol: 'mnn_interpreter_update_cache_file')
external int _mnn_interpreter_update_cache_file(
  mnn_interpreter_t self,
  mnn_session_t session,
  int flag,
);

ErrorCode mnn_interpreter_update_cache_file(
  mnn_interpreter_t self,
  mnn_session_t session,
  int flag,
) =>
    ErrorCode.fromValue(_mnn_interpreter_update_cache_file(
      self,
      session,
      flag,
    ));

/// @brief Update session to model
/// @param self Interpreter instance
/// @param session Session
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t)>(
    symbol: 'mnn_interpreter_update_session_to_model')
external int _mnn_interpreter_update_session_to_model(
  mnn_interpreter_t self,
  mnn_session_t session,
);

ErrorCode mnn_interpreter_update_session_to_model(
  mnn_interpreter_t self,
  mnn_session_t session,
) =>
    ErrorCode.fromValue(_mnn_interpreter_update_session_to_model(
      self,
      session,
    ));

/// @brief Get uuid from interpreter
/// @param self Interpreter instance
/// @return Uuid string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_uuid(
  mnn_interpreter_t self,
);

/// @brief Destroy runtime info
/// @param runtime Runtime info to destroy
@ffi.Native<ffi.Void Function(mnn_runtime_info_t)>()
external void mnn_runtime_info_destroy(
  mnn_runtime_info_t runtime,
);

/// @brief Get tensor batch
/// @param self Tensor
/// @return Batch
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_batch(
  mnn_tensor_t self,
);

/// @brief Get buffer
/// @param self Tensor
/// @return Buffer pointer
@ffi.Native<ffi.Pointer<halide_buffer_t> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<halide_buffer_t> mnn_tensor_buffer(
  mnn_tensor_t self,
);

/// @brief Get tensor channel
/// @param self Tensor
/// @return Channel
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_channel(
  mnn_tensor_t self,
);

/// @brief Clone tensor
/// @param src Source tensor
/// @param deep_copy Whether to perform deep copy
/// @return Cloned tensor or NULL if failed
@ffi.Native<mnn_tensor_t Function(mnn_tensor_t, ffi.Bool)>()
external mnn_tensor_t mnn_tensor_clone(
  mnn_tensor_t src,
  bool deep_copy,
);

/// @brief Copy data from host tensor
/// @param self Target tensor
/// @param host_tensor Source tensor
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, mnn_tensor_t)>(
    symbol: 'mnn_tensor_copy_from_host')
external int _mnn_tensor_copy_from_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
);

ErrorCode mnn_tensor_copy_from_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
) =>
    ErrorCode.fromValue(_mnn_tensor_copy_from_host(
      self,
      host_tensor,
    ));

/// @brief Copy data to host tensor
/// @param self Source tensor
/// @param host_tensor Target tensor
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, mnn_tensor_t)>(
    symbol: 'mnn_tensor_copy_to_host')
external int _mnn_tensor_copy_to_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
);

ErrorCode mnn_tensor_copy_to_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
) =>
    ErrorCode.fromValue(_mnn_tensor_copy_to_host(
      self,
      host_tensor,
    ));

/// @brief Create tensor with dimension size and type
/// @param dim_size Dimension size
/// @param type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<mnn_tensor_t Function(ffi.Int, ffi.UnsignedInt)>(
    symbol: 'mnn_tensor_create')
external mnn_tensor_t _mnn_tensor_create(
  int dim_size,
  int type,
);

mnn_tensor_t mnn_tensor_create(
  int dim_size,
  DimensionType type,
) =>
    _mnn_tensor_create(
      dim_size,
      type.value,
    );

/// @brief Create device tensor
/// @param shape Tensor shape array
/// @param shape_size Shape array size
/// @param type Data type
/// @param dim_type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(ffi.Pointer<ffi.Int>, ffi.Int, halide_type_t,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_create_device')
external mnn_tensor_t _mnn_tensor_create_device(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_t type,
  int dim_type,
);

mnn_tensor_t mnn_tensor_create_device(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_t type,
  DimensionType dim_type,
) =>
    _mnn_tensor_create_device(
      shape,
      shape_size,
      type,
      dim_type.value,
    );

/// @brief Create tensor with same shape as given tensor
/// @param self Shape provider
/// @param type Dimension type
/// @param alloc_memory Whether allocate memory
/// @return Tensor instance or NULL if failed
@ffi.Native<mnn_tensor_t Function(mnn_tensor_t, ffi.UnsignedInt, ffi.Bool)>(
    symbol: 'mnn_tensor_create_from_tensor')
external mnn_tensor_t _mnn_tensor_create_from_tensor(
  mnn_tensor_t self,
  int type,
  bool alloc_memory,
);

mnn_tensor_t mnn_tensor_create_from_tensor(
  mnn_tensor_t self,
  DimensionType type,
  bool alloc_memory,
) =>
    _mnn_tensor_create_from_tensor(
      self,
      type.value,
      alloc_memory,
    );

/// @brief Create tensor with data
/// @param shape Tensor shape array
/// @param shape_size Shape array size
/// @param type Data type
/// @param data Data pointer
/// @param dim_type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        halide_type_t,
        ffi.Pointer<ffi.Void>,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_create_with_data')
external mnn_tensor_t _mnn_tensor_create_with_data(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_t type,
  ffi.Pointer<ffi.Void> data,
  int dim_type,
);

mnn_tensor_t mnn_tensor_create_with_data(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_t type,
  ffi.Pointer<ffi.Void> data,
  DimensionType dim_type,
) =>
    _mnn_tensor_create_with_data(
      shape,
      shape_size,
      type,
      data,
      dim_type.value,
    );

/// @brief Destroy tensor
/// @param tensor Tensor to destroy
@ffi.Native<ffi.Void Function(mnn_tensor_t)>(isLeaf: true)
external void mnn_tensor_destroy(
  mnn_tensor_t tensor,
);

/// @brief Get device ID
/// @param self Tensor
/// @return Device ID
@ffi.Native<ffi.Uint64 Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_device_id(
  mnn_tensor_t self,
);

/// @brief Get tensor dimensions
/// @param self Tensor
/// @return Dimension count
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_dimensions(
  mnn_tensor_t self,
);

/// @brief Get tensor element count
/// @param self Tensor
/// @return Element count
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_element_size(
  mnn_tensor_t self,
);

/// @brief Get dimension type
/// @param self Tensor
/// @return Dimension type
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t)>(
    symbol: 'mnn_tensor_get_dimension_type', isLeaf: true)
external int _mnn_tensor_get_dimension_type(
  mnn_tensor_t self,
);

DimensionType mnn_tensor_get_dimension_type(
  mnn_tensor_t self,
) =>
    DimensionType.fromValue(_mnn_tensor_get_dimension_type(
      self,
    ));

/// @brief Get handle data type
/// @param self Tensor
/// @return Handle data type
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t)>(
    symbol: 'mnn_tensor_get_handle_data_type', isLeaf: true)
external int _mnn_tensor_get_handle_data_type(
  mnn_tensor_t self,
);

HandleDataType mnn_tensor_get_handle_data_type(
  mnn_tensor_t self,
) =>
    HandleDataType.fromValue(_mnn_tensor_get_handle_data_type(
      self,
    ));

/// @brief Get data type
/// @param self Tensor
/// @return Data type
@ffi.Native<ffi.Pointer<halide_type_t> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<halide_type_t> mnn_tensor_get_type(
  mnn_tensor_t self,
);

/// @brief Get tensor height
/// @param self Tensor
/// @return Height
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_height(
  mnn_tensor_t self,
);

/// @brief Get host data pointer
/// @param self Tensor
/// @return Data pointer or NULL
@ffi.Native<ffi.Pointer<ffi.Void> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<ffi.Void> mnn_tensor_host(
  mnn_tensor_t self,
);

/// @brief Get tensor length
/// @param self Tensor
/// @param index Dimension index
/// @return Length
@ffi.Native<ffi.Int Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external int mnn_tensor_length(
  mnn_tensor_t self,
  int index,
);

/// @brief Map tensor for access
/// @param self Tensor
/// @param mtype Map type
/// @param dtype Dimension type
/// @return Mapped pointer or NULL
@ffi.Native<
    ffi.Pointer<ffi.Void> Function(mnn_tensor_t, ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_map', isLeaf: true)
external ffi.Pointer<ffi.Void> _mnn_tensor_map(
  mnn_tensor_t self,
  int mtype,
  int dtype,
);

ffi.Pointer<ffi.Void> mnn_tensor_map(
  mnn_tensor_t self,
  MapType mtype,
  DimensionType dtype,
) =>
    _mnn_tensor_map(
      self,
      mtype.value,
      dtype.value,
    );

@ffi.Native<ffi.Void Function(mnn_tensor_t)>()
external void mnn_tensor_print(
  mnn_tensor_t self,
);

@ffi.Native<ffi.Void Function(mnn_tensor_t)>()
external void mnn_tensor_print_shape(
  mnn_tensor_t self,
);

/// @brief Set device pointer
/// @param self Tensor
/// @param device_ptr Device pointer
/// @param memory_type Memory type
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_tensor_t, ffi.Pointer<ffi.Void>, ffi.Int)>(
    symbol: 'mnn_tensor_set_device_ptr', isLeaf: true)
external int _mnn_tensor_set_device_ptr(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Void> device_ptr,
  int memory_type,
);

ErrorCode mnn_tensor_set_device_ptr(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Void> device_ptr,
  int memory_type,
) =>
    ErrorCode.fromValue(_mnn_tensor_set_device_ptr(
      self,
      device_ptr,
      memory_type,
    ));

/// @brief Set tensor length
/// @param self Tensor
/// @param index Dimension index
/// @param length Length value
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_length(
  mnn_tensor_t self,
  int index,
  int length,
);

/// @brief Set tensor stride
/// @param self Tensor
/// @param index Dimension index
/// @param stride Stride value
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_stride(
  mnn_tensor_t self,
  int index,
  int stride,
);

/// @brief Set data type
/// @param self Tensor
/// @param type Data type
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_type(
  mnn_tensor_t self,
  int type,
);

/// @brief Get tensor shape
/// @param self Tensor
/// @param shape Output shape array (must be pre-allocated)
/// @param shape_size Shape array size
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_tensor_t, ffi.Pointer<ffi.Int>, ffi.Int)>(
    symbol: 'mnn_tensor_shape', isLeaf: true)
external int _mnn_tensor_shape(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
);

ErrorCode mnn_tensor_shape(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
) =>
    ErrorCode.fromValue(_mnn_tensor_shape(
      self,
      shape,
      shape_size,
    ));

/// @brief Get tensor data size in bytes
/// @param self Tensor
/// @return Size in bytes
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_size(
  mnn_tensor_t self,
);

/// @brief Get tensor stride
/// @param self Tensor
/// @param index Dimension index
/// @return Stride
@ffi.Native<ffi.Int Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external int mnn_tensor_stride(
  mnn_tensor_t self,
  int index,
);

/// @brief Unmap tensor
/// @param self Tensor
/// @param mtype Map type
/// @param dtype Dimension type
/// @param map_ptr Mapped pointer
@ffi.Native<
    ffi.Void Function(mnn_tensor_t, ffi.UnsignedInt, ffi.UnsignedInt,
        ffi.Pointer<ffi.Void>)>(symbol: 'mnn_tensor_unmap', isLeaf: true)
external void _mnn_tensor_unmap(
  mnn_tensor_t self,
  int mtype,
  int dtype,
  ffi.Pointer<ffi.Void> map_ptr,
);

void mnn_tensor_unmap(
  mnn_tensor_t self,
  MapType mtype,
  DimensionType dtype,
  ffi.Pointer<ffi.Void> map_ptr,
) =>
    _mnn_tensor_unmap(
      self,
      mtype.value,
      dtype.value,
      map_ptr,
    );

/// @brief Get tensor shape in bytes (unsigned)
/// @param self Tensor
/// @return Size in bytes
@ffi.Native<ffi.Size Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_usize(
  mnn_tensor_t self,
);

/// @brief Wait for tensor ready
/// @param self Tensor
/// @param mtype Map type
/// @param finish Whether wait for finish
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, ffi.UnsignedInt, ffi.Bool)>(
    symbol: 'mnn_tensor_wait')
external int _mnn_tensor_wait(
  mnn_tensor_t self,
  int mtype,
  bool finish,
);

ErrorCode mnn_tensor_wait(
  mnn_tensor_t self,
  MapType mtype,
  bool finish,
) =>
    ErrorCode.fromValue(_mnn_tensor_wait(
      self,
      mtype.value,
      finish,
    ));

/// @brief Get tensor width
/// @param self Tensor
/// @return Width
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_width(
  mnn_tensor_t self,
);

/// @brief Creates a new timer instance
/// @return Pointer to the newly created timer
@ffi.Native<mnn_timer_t Function()>()
external mnn_timer_t mnn_timer_create();

/// @brief Gets the current time value from timer
/// @param timer Timer instance to query
/// @return Current time value
@ffi.Native<ffi.Uint64 Function(mnn_timer_t)>()
external int mnn_timer_current(
  mnn_timer_t timer,
);

/// @brief Destroys a timer instance
/// @param timer Timer instance to destroy
@ffi.Native<ffi.Void Function(mnn_timer_t)>()
external void mnn_timer_destroy(
  mnn_timer_t timer,
);

/// @brief Gets the duration in microseconds since last reset
/// @param timer Timer instance to query
/// @return Duration in microseconds
@ffi.Native<ffi.Uint64 Function(mnn_timer_t)>()
external int mnn_timer_duration_us(
  mnn_timer_t timer,
);

/// @brief Resets the timer to current time
/// @param timer Timer instance to reset
@ffi.Native<ffi.Void Function(mnn_timer_t)>()
external void mnn_timer_reset(
  mnn_timer_t timer,
);

const addresses = _SymbolAddresses();

class _SymbolAddresses {
  const _SymbolAddresses();
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_auto_time_t)>>
      get mnn_auto_time_destroy =>
          ffi.Native.addressOf(self.mnn_auto_time_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_interpreter_t)>>
      get mnn_interpreter_destroy =>
          ffi.Native.addressOf(self.mnn_interpreter_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_runtime_info_t)>>
      get mnn_runtime_info_destroy =>
          ffi.Native.addressOf(self.mnn_runtime_info_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_tensor_t)>>
      get mnn_tensor_destroy => ffi.Native.addressOf(self.mnn_tensor_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_timer_t)>>
      get mnn_timer_destroy => ffi.Native.addressOf(self.mnn_timer_destroy);
}

enum DimensionType {
  MNN_TENSORFLOW(0),
  MNN_CAFFE(1),
  MNN_CAFFE_C4(2);

  final int value;
  const DimensionType(this.value);

  static DimensionType fromValue(int value) => switch (value) {
        0 => MNN_TENSORFLOW,
        1 => MNN_CAFFE,
        2 => MNN_CAFFE_C4,
        _ => throw ArgumentError('Unknown value for DimensionType: $value'),
      };
}

/// Error code enum
enum ErrorCode {
  NO_ERROR(0),
  OUT_OF_MEMORY(1),
  NOT_SUPPORT(2),
  COMPUTE_SIZE_ERROR(3),
  NO_EXECUTION(4),
  INVALID_VALUE(5),

  /// User error
  INPUT_DATA_ERROR(10),
  CALL_BACK_STOP(11),

  /// Op Resize Error
  TENSOR_NOT_SUPPORT(20),
  TENSOR_NEED_DIVIDE(21),

  /// File error
  FILE_CREATE_FAILED(30),
  FILE_REMOVE_FAILED(31),
  FILE_OPEN_FAILED(32),
  FILE_CLOSE_FAILED(33),
  FILE_RESIZE_FAILED(34),
  FILE_SEEK_FAILED(35),
  FILE_NOT_EXIST(36),
  FILE_UNMAP_FAILED(37),

  /// custom
  BOOL_TRUE(100),
  BOOL_FALSE(101),
  UNKNOWN_ERROR(102),
  MNN_INVALID_PTR(103);

  final int value;
  const ErrorCode(this.value);

  static ErrorCode fromValue(int value) => switch (value) {
        0 => NO_ERROR,
        1 => OUT_OF_MEMORY,
        2 => NOT_SUPPORT,
        3 => COMPUTE_SIZE_ERROR,
        4 => NO_EXECUTION,
        5 => INVALID_VALUE,
        10 => INPUT_DATA_ERROR,
        11 => CALL_BACK_STOP,
        20 => TENSOR_NOT_SUPPORT,
        21 => TENSOR_NEED_DIVIDE,
        30 => FILE_CREATE_FAILED,
        31 => FILE_REMOVE_FAILED,
        32 => FILE_OPEN_FAILED,
        33 => FILE_CLOSE_FAILED,
        34 => FILE_RESIZE_FAILED,
        35 => FILE_SEEK_FAILED,
        36 => FILE_NOT_EXIST,
        37 => FILE_UNMAP_FAILED,
        100 => BOOL_TRUE,
        101 => BOOL_FALSE,
        102 => UNKNOWN_ERROR,
        103 => MNN_INVALID_PTR,
        _ => throw ArgumentError('Unknown value for ErrorCode: $value'),
      };
}

/// Types in the halide type system. They can be ints, unsigned ints,
/// or floats (of various bit-widths), or a handle (which is always 64-bits).
/// Note that the int/uint/float values do not imply a specific bit width
/// (the bit width is expected to be encoded in a separate value).
enum HalideTypeCode {
  /// !< signed integers
  halide_type_int(0),

  /// !< unsigned integers
  halide_type_uint(1),

  /// !< IEEE floating point numbers
  halide_type_float(2),

  /// !< opaque pointer type (void *)
  halide_type_handle(3),

  /// !< floating point numbers in the bfloat format
  halide_type_bfloat(4);

  final int value;
  const HalideTypeCode(this.value);

  static HalideTypeCode fromValue(int value) => switch (value) {
        0 => halide_type_int,
        1 => halide_type_uint,
        2 => halide_type_float,
        3 => halide_type_handle,
        4 => halide_type_bfloat,
        _ => throw ArgumentError('Unknown value for HalideTypeCode: $value'),
      };
}

enum HandleDataType {
  MNN_HANDLE_NONE(0),
  MNN_HANDLE_STRING(1);

  final int value;
  const HandleDataType(this.value);

  static HandleDataType fromValue(int value) => switch (value) {
        0 => MNN_HANDLE_NONE,
        1 => MNN_HANDLE_STRING,
        _ => throw ArgumentError('Unknown value for HandleDataType: $value'),
      };
}

enum MapType {
  MNN_MAP_TENSOR_WRITE(0),
  MNN_MAP_TENSOR_READ(1);

  final int value;
  const MapType(this.value);

  static MapType fromValue(int value) => switch (value) {
        0 => MNN_MAP_TENSOR_WRITE,
        1 => MNN_MAP_TENSOR_READ,
        _ => throw ArgumentError('Unknown value for MapType: $value'),
      };
}

final class UnnamedUnion1 extends ffi.Union {
  external ffi.Pointer<ffi.Void> sharedContext;

  @ffi.Size()
  external int flags;
}

/// CPU:number of threads in parallel , Or GPU: mode setting
final class UnnamedUnion2 extends ffi.Union {
  @ffi.Int()
  external int num_thread;

  @ffi.Int()
  external int mode;
}

enum halide_buffer_flags {
  halide_buffer_flag_host_dirty(1),
  halide_buffer_flag_device_dirty(2);

  final int value;
  const halide_buffer_flags(this.value);

  static halide_buffer_flags fromValue(int value) => switch (value) {
        1 => halide_buffer_flag_host_dirty,
        2 => halide_buffer_flag_device_dirty,
        _ =>
          throw ArgumentError('Unknown value for halide_buffer_flags: $value'),
      };
}

/// The raw representation of an image passed around by generated
/// Halide code. It includes some stuff to track whether the image is
/// not actually in main memory, but instead on a device (like a
/// GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>.
final class halide_buffer_t extends ffi.Struct {
  /// A device-handle for e.g. GPU memory used to back this buffer.
  @ffi.Uint64()
  external int device;

  /// The interface used to interpret the above handle.
  external ffi.Pointer<halide_device_interface_t> device_interface;

  /// A pointer to the start of the data in main memory. In terms of
  /// the Halide coordinate system, this is the address of the min
  /// coordinates (defined below).
  external ffi.Pointer<ffi.Uint8> host;

  /// flags with various meanings.
  @ffi.Uint64()
  external int flags;

  /// The type of each buffer element.
  external halide_type_t type;

  /// The dimensionality of the buffer.
  @ffi.Int32()
  external int dimensions;

  /// The shape of the buffer. Halide does not own this array - you
  /// must manage the memory for it yourself.
  external ffi.Pointer<halide_dimension_t> dim;

  /// Pads the buffer up to a multiple of 8 bytes
  external ffi.Pointer<ffi.Void> padding;
}

/// An opaque struct containing per-GPU API implementations of the
/// device functions.
final class halide_device_interface_impl_t extends ffi.Opaque {}

/// Each GPU API provides a halide_device_interface_t struct pointing
/// to the code that manages device allocations. You can access these
/// functions directly from the struct member function pointers, or by
/// calling the functions declared below. Note that the global
/// functions are not available when using Halide as a JIT compiler.
/// If you are using raw halide_buffer_t in that context you must use
/// the function pointers in the device_interface struct.
///
/// The function pointers below are currently the same for every GPU
/// API; only the impl field varies. These top-level functions do the
/// bookkeeping that is common across all GPU APIs, and then dispatch
/// to more API-specific functions via another set of function pointers
/// hidden inside the impl field.
final class halide_device_interface_t extends ffi.Struct {
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_malloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_sync;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_release;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> copy_to_host;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      copy_to_device;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_and_host_malloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_and_host_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> src,
              ffi.Pointer<halide_device_interface_t> dst_device_interface,
              ffi.Pointer<halide_buffer_t> dst)>> buffer_copy;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> src,
              ffi.Pointer<halide_buffer_t> dst)>> device_crop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_release_crop;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Uint64 handle,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      wrap_native;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> detach_native;

  external ffi.Pointer<halide_device_interface_impl_t> impl;
}

final class halide_dimension_t extends ffi.Struct {
  @ffi.Int32()
  external int min;

  @ffi.Int32()
  external int extent;

  @ffi.Int32()
  external int stride;

  /// Per-dimension flags. None are defined yet (This is reserved for future use).
  @ffi.Uint32()
  external int flags;
}

/// A runtime tag for a type in the halide type system. Can be ints,
/// unsigned ints, or floats of various bit-widths (the 'bits'
/// field). Can also be vectors of the same (by setting the 'lanes'
/// field to something larger than one). This struct should be
/// exactly 32-bits in size.
final class halide_type_t extends ffi.Struct {
  /// halide_type_code_t
  @ffi.UnsignedInt()
  external int codeAsInt;

  HalideTypeCode get code => HalideTypeCode.fromValue(codeAsInt);

  /// The number of bits of precision of a single scalar value of this type.
  @ffi.Uint8()
  external int bits;

  /// How many elements in a vector. This is 1 for scalar types.
  @ffi.Uint16()
  external int lanes;
}

typedef mnn_auto_time_t = ffi.Pointer<ffi.Void>;

final class mnn_backend_config_t extends ffi.Struct {
  /// mnn_memory_mode memory;
  @ffi.Int()
  external int memory;

  /// mnn_power_mode power;
  @ffi.Int()
  external int power;

  /// mnn_precision_mode precision;
  @ffi.Int()
  external int precision;

  external UnnamedUnion1 unnamed;
}

typedef mnn_backend_t = ffi.Pointer<ffi.Void>;

/// typedef struct {
/// uint8_t code;
/// uint8_t bits;
/// uint16_t lanes;
/// } halide_type_c_t;
typedef mnn_callback_0
    = ffi.Pointer<ffi.NativeFunction<mnn_callback_0Function>>;
typedef mnn_callback_0Function = ffi.Void Function();
typedef Dartmnn_callback_0Function = void Function();

/// Forward type enum */
/// // typedef mnn_forward_type mnn_forward_type_t;
typedef mnn_forward_type_t = ffi.Int;
typedef Dartmnn_forward_type_t = int;
typedef mnn_interpreter_t = ffi.Pointer<ffi.Void>;
typedef mnn_runtime_info_t = ffi.Pointer<ffi.Void>;

/// Schedule config structure
final class mnn_schedule_config_t extends ffi.Struct {
  @mnn_forward_type_t()
  external int type;

  /// CPU:number of threads in parallel , Or GPU: mode setting
  external UnnamedUnion2 unnamed;

  @mnn_forward_type_t()
  external int backupType;

  external ffi.Pointer<mnn_backend_config_t> backend_config;
}

typedef mnn_session_t = ffi.Pointer<ffi.Void>;

enum mnn_tensor_dtype {
  MNN_T_D_TYPE_F32_F64(0),
  MNN_T_D_TYPE_BF16(1),
  MNN_T_D_TYPE_QI32_I32_BOOL_I64(2),
  MNN_T_D_TYPE_QI8_I8(3),
  MNN_T_D_TYPE_QU8_U8(4),
  MNN_T_D_TYPE_QU16_U16(5),
  MNN_T_D_TYPE_QI16_I16(6);

  final int value;
  const mnn_tensor_dtype(this.value);

  static mnn_tensor_dtype fromValue(int value) => switch (value) {
        0 => MNN_T_D_TYPE_F32_F64,
        1 => MNN_T_D_TYPE_BF16,
        2 => MNN_T_D_TYPE_QI32_I32_BOOL_I64,
        3 => MNN_T_D_TYPE_QI8_I8,
        4 => MNN_T_D_TYPE_QU8_U8,
        5 => MNN_T_D_TYPE_QU16_U16,
        6 => MNN_T_D_TYPE_QI16_I16,
        _ => throw ArgumentError('Unknown value for mnn_tensor_dtype: $value'),
      };
}

typedef mnn_tensor_t = ffi.Pointer<ffi.Void>;
typedef mnn_timer_t = ffi.Pointer<ffi.Void>;
