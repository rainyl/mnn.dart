// Copyright (c) 2025, rainyl.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('package:mnn/mnn.dart')
library;

import 'dart:ffi' as ffi;
import '' as self;

/// @brief Creates a new auto timer instance
/// @param line Source code line number (for debugging)
/// @param func Function name (for debugging)
/// @return Pointer to the newly created auto timer
@ffi.Native<mnn_auto_time_t Function(ffi.Int, ffi.Pointer<ffi.Char>)>()
external mnn_auto_time_t mnn_auto_time_create(
  int line,
  ffi.Pointer<ffi.Char> func,
);

/// @brief Destroys an auto timer instance
/// @param auto_time Auto timer instance to destroy
@ffi.Native<ffi.Void Function(mnn_auto_time_t)>()
external void mnn_auto_time_destroy(
  mnn_auto_time_t auto_time,
);

@ffi.Native<
    ffi.UnsignedInt Function(
        mnn_cv_image_process_t,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        mnn_tensor_t)>(symbol: 'mnn_cv_image_process_convert')
external int _mnn_cv_image_process_convert(
  mnn_cv_image_process_t self,
  ffi.Pointer<ffi.Uint8> src,
  int iw,
  int ih,
  int stride,
  mnn_tensor_t dest,
);

ErrorCode mnn_cv_image_process_convert(
  mnn_cv_image_process_t self,
  ffi.Pointer<ffi.Uint8> src,
  int iw,
  int ih,
  int stride,
  mnn_tensor_t dest,
) =>
    ErrorCode.fromValue(_mnn_cv_image_process_convert(
      self,
      src,
      iw,
      ih,
      stride,
      dest,
    ));

@ffi.Native<
    ffi.UnsignedInt Function(
        mnn_cv_image_process_t,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Void>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        halide_type_c_t)>(symbol: 'mnn_cv_image_process_convert_1')
external int _mnn_cv_image_process_convert_1(
  mnn_cv_image_process_t self,
  ffi.Pointer<ffi.Uint8> src,
  int iw,
  int ih,
  int stride,
  ffi.Pointer<ffi.Void> dst,
  int ow,
  int oh,
  int outputBpp,
  int outputStride,
  halide_type_c_t type,
);

ErrorCode mnn_cv_image_process_convert_1(
  mnn_cv_image_process_t self,
  ffi.Pointer<ffi.Uint8> src,
  int iw,
  int ih,
  int stride,
  ffi.Pointer<ffi.Void> dst,
  int ow,
  int oh,
  int outputBpp,
  int outputStride,
  halide_type_c_t type,
) =>
    ErrorCode.fromValue(_mnn_cv_image_process_convert_1(
      self,
      src,
      iw,
      ih,
      stride,
      dst,
      ow,
      oh,
      outputBpp,
      outputStride,
      type,
    ));

/// /////////////// ImageProcess //////////////////////////
@ffi.Native<
    mnn_cv_image_process_t Function(
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        mnn_tensor_t)>()
external mnn_cv_image_process_t mnn_cv_image_process_create(
  int sourceFormat,
  int destFormat,
  ffi.Pointer<ffi.Float> means,
  int mean_count,
  ffi.Pointer<ffi.Float> normals,
  int normal_count,
  int filterType,
  int wrap,
  mnn_tensor_t dst_tensor,
);

@ffi.Native<
    mnn_tensor_t Function(
        halide_type_c_t, ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>)>()
external mnn_tensor_t mnn_cv_image_process_create_image_tensor(
  halide_type_c_t type,
  int width,
  int height,
  int bytes_per_channel,
  ffi.Pointer<ffi.Void> p,
);

@ffi.Native<
    mnn_cv_image_process_t Function(mnn_image_process_config_t, mnn_tensor_t)>()
external mnn_cv_image_process_t mnn_cv_image_process_create_with_config(
  mnn_image_process_config_t config,
  mnn_tensor_t dst_tensor,
);

@ffi.Native<ffi.Void Function(mnn_cv_image_process_t)>()
external void mnn_cv_image_process_destroy(
  mnn_cv_image_process_t self,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_image_process_t,
        ffi.Pointer<ffi.Uint8>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        ffi.Pointer<ffi.Uint8>)>()
external void mnn_cv_image_process_draw(
  mnn_cv_image_process_t self,
  ffi.Pointer<ffi.Uint8> img,
  int w,
  int h,
  int c,
  ffi.Pointer<ffi.Int> regions,
  int num,
  ffi.Pointer<ffi.Uint8> color,
);

/// Matrix operations for ImageProcess
@ffi.Native<mnn_cv_matrix_t Function(mnn_cv_image_process_t)>()
external mnn_cv_matrix_t mnn_cv_image_process_get_matrix(
  mnn_cv_image_process_t self,
);

@ffi.Native<ffi.Void Function(mnn_cv_image_process_t)>()
external void mnn_cv_image_process_set_draw(
  mnn_cv_image_process_t self,
);

@ffi.Native<ffi.UnsignedInt Function(mnn_cv_image_process_t, mnn_cv_matrix_t)>(
    symbol: 'mnn_cv_image_process_set_matrix')
external int _mnn_cv_image_process_set_matrix(
  mnn_cv_image_process_t self,
  mnn_cv_matrix_t matrix,
);

ErrorCode mnn_cv_image_process_set_matrix(
  mnn_cv_image_process_t self,
  mnn_cv_matrix_t matrix,
) =>
    ErrorCode.fromValue(_mnn_cv_image_process_set_matrix(
      self,
      matrix,
    ));

@ffi.Native<ffi.Void Function(mnn_cv_image_process_t, ffi.Uint8)>()
external void mnn_cv_image_process_set_padding(
  mnn_cv_image_process_t self,
  int value,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t, mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_cheap_equal_to(
  mnn_cv_matrix_t self,
  mnn_cv_matrix_t other,
);

/// Matrix operations
@ffi.Native<mnn_cv_matrix_t Function()>()
external mnn_cv_matrix_t mnn_cv_matrix_create();

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t)>()
external void mnn_cv_matrix_destroy(
  mnn_cv_matrix_t self,
);

/// MNN_C_API float mnn_cv_matrix_get_min_scale(mnn_cv_matrix_t self);
/// MNN_C_API float mnn_cv_matrix_get_max_scale(mnn_cv_matrix_t self);
@ffi.Native<ffi.Void Function(mnn_cv_matrix_t)>()
external void mnn_cv_matrix_dirty_matrix_type_cache(
  mnn_cv_matrix_t self,
);

/// Matrix getters
@ffi.Native<ffi.Float Function(mnn_cv_matrix_t, ffi.Int)>()
external double mnn_cv_matrix_get(
  mnn_cv_matrix_t self,
  int index,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Pointer<ffi.Float>)>()
external void mnn_cv_matrix_get9(
  mnn_cv_matrix_t self,
  ffi.Pointer<ffi.Float> m,
);

/// Matrix type masks
@ffi.Native<ffi.Int Function(mnn_cv_matrix_t)>()
external int mnn_cv_matrix_get_type(
  mnn_cv_matrix_t self,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t, mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_invert(
  mnn_cv_matrix_t self,
  mnn_cv_matrix_t dst,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_is_identity(
  mnn_cv_matrix_t self,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_is_scale_translate(
  mnn_cv_matrix_t self,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_is_translate(
  mnn_cv_matrix_t self,
);

@ffi.Native<
    ffi.Bool Function(mnn_cv_matrix_t, ffi.Pointer<mnn_cv_point_t>,
        ffi.Pointer<mnn_cv_point_t>, ffi.Int)>()
external bool mnn_cv_matrix_map_points(
  mnn_cv_matrix_t self,
  ffi.Pointer<mnn_cv_point_t> dst,
  ffi.Pointer<mnn_cv_point_t> src,
  int count,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Pointer<mnn_cv_point_t>, ffi.Int)>()
external void mnn_cv_matrix_map_points_inplace(
  mnn_cv_matrix_t self,
  ffi.Pointer<mnn_cv_point_t> points,
  int count,
);

@ffi.Native<
    ffi.Bool Function(mnn_cv_matrix_t, ffi.Pointer<mnn_cv_rect_t>,
        ffi.Pointer<mnn_cv_rect_t>)>()
external bool mnn_cv_matrix_map_rect(
  mnn_cv_matrix_t self,
  ffi.Pointer<mnn_cv_rect_t> dst,
  ffi.Pointer<mnn_cv_rect_t> src,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Pointer<mnn_cv_rect_t>,
        ffi.Pointer<mnn_cv_rect_t>)>()
external void mnn_cv_matrix_map_rect_scale_translate(
  mnn_cv_matrix_t self,
  ffi.Pointer<mnn_cv_rect_t> dst,
  ffi.Pointer<mnn_cv_rect_t> src,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float,
        ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>)>()
external void mnn_cv_matrix_map_xy(
  mnn_cv_matrix_t self,
  double x,
  double y,
  ffi.Pointer<ffi.Float> mapped_x,
  ffi.Pointer<ffi.Float> mapped_y,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, mnn_cv_matrix_t)>()
external void mnn_cv_matrix_post_concat(
  mnn_cv_matrix_t self,
  mnn_cv_matrix_t other,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Int, ffi.Int)>()
external void mnn_cv_matrix_post_idiv(
  mnn_cv_matrix_t self,
  int divx,
  int divy,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_post_rotate(
  mnn_cv_matrix_t self,
  double degrees,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_post_scale(
  mnn_cv_matrix_t self,
  double sx,
  double sy,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_post_skew(
  mnn_cv_matrix_t self,
  double kx,
  double ky,
  double px,
  double py,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_post_translate(
  mnn_cv_matrix_t self,
  double dx,
  double dy,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, mnn_cv_matrix_t)>()
external void mnn_cv_matrix_pre_concat(
  mnn_cv_matrix_t self,
  mnn_cv_matrix_t other,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_pre_rotate(
  mnn_cv_matrix_t self,
  double degrees,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_pre_scale(
  mnn_cv_matrix_t self,
  double sx,
  double sy,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_pre_skew(
  mnn_cv_matrix_t self,
  double kx,
  double ky,
  double px,
  double py,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_pre_translate(
  mnn_cv_matrix_t self,
  double dx,
  double dy,
);

@ffi.Native<ffi.Bool Function(mnn_cv_matrix_t)>()
external bool mnn_cv_matrix_rect_stays_rect(
  mnn_cv_matrix_t self,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t)>()
external void mnn_cv_matrix_reset(
  mnn_cv_matrix_t self,
);

/// Matrix setters
@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Int, ffi.Float)>()
external void mnn_cv_matrix_set(
  mnn_cv_matrix_t self,
  int index,
  double value,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Pointer<ffi.Float>)>()
external void mnn_cv_matrix_set9(
  mnn_cv_matrix_t self,
  ffi.Pointer<ffi.Float> m,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float,
        ffi.Float, ffi.Float, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_all(
  mnn_cv_matrix_t self,
  double scaleX,
  double skewX,
  double transX,
  double skewY,
  double scaleY,
  double transY,
  double pers0,
  double pers1,
  double pers2,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, mnn_cv_matrix_t, mnn_cv_matrix_t)>()
external void mnn_cv_matrix_set_concat(
  mnn_cv_matrix_t self,
  mnn_cv_matrix_t a,
  mnn_cv_matrix_t b,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t)>()
external void mnn_cv_matrix_set_identity(
  mnn_cv_matrix_t self,
);

@ffi.Native<
    ffi.Bool Function(mnn_cv_matrix_t, ffi.Pointer<mnn_cv_point_t>,
        ffi.Pointer<mnn_cv_point_t>, ffi.Int)>()
external bool mnn_cv_matrix_set_poly_to_poly(
  mnn_cv_matrix_t self,
  ffi.Pointer<mnn_cv_point_t> src,
  ffi.Pointer<mnn_cv_point_t> dst,
  int count,
);

@ffi.Native<
    ffi.Bool Function(mnn_cv_matrix_t, mnn_cv_rect_t, mnn_cv_rect_t, ffi.Int)>()
external bool mnn_cv_matrix_set_rect_to_rect(
  mnn_cv_matrix_t self,
  mnn_cv_rect_t src,
  mnn_cv_rect_t dst,
  int scale_to_fit,
);

@ffi.Native<
    ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_rotate(
  mnn_cv_matrix_t self,
  double degrees,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_scale(
  mnn_cv_matrix_t self,
  double sx,
  double sy,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_scale_translate(
  mnn_cv_matrix_t self,
  double sx,
  double sy,
  double tx,
  double ty,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_sincos(
  mnn_cv_matrix_t self,
  double sin,
  double cos,
  double px,
  double py,
);

@ffi.Native<
    ffi.Void Function(
        mnn_cv_matrix_t, ffi.Float, ffi.Float, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_skew(
  mnn_cv_matrix_t self,
  double kx,
  double ky,
  double px,
  double py,
);

@ffi.Native<ffi.Void Function(mnn_cv_matrix_t, ffi.Float, ffi.Float)>()
external void mnn_cv_matrix_set_translate(
  mnn_cv_matrix_t self,
  double dx,
  double dy,
);

/// @brief Get MNN version
/// @return Version string
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> mnn_get_version();

/// @brief Get biz code from interpreter
/// @param self Interpreter instance
/// @return Biz code string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_biz_code(
  mnn_interpreter_t self,
);

/// @brief Create interpreter from buffer
/// @param buffer Model data buffer
/// @param size Buffer size
/// @param callback Callback function to be called after creation
/// @return Interpreter instance or NULL if failed
@ffi.Native<
    mnn_interpreter_t Function(
        ffi.Pointer<ffi.Void>, ffi.Size, mnn_callback_0)>()
external mnn_interpreter_t mnn_interpreter_create_from_buffer(
  ffi.Pointer<ffi.Void> buffer,
  int size,
  mnn_callback_0 callback,
);

/// @brief Create interpreter from file
/// @param file_path Path to model file
/// @param callback Callback function to be called after creation
/// @return Interpreter instance or NULL if failed
@ffi.Native<mnn_interpreter_t Function(ffi.Pointer<ffi.Char>, mnn_callback_0)>()
external mnn_interpreter_t mnn_interpreter_create_from_file(
  ffi.Pointer<ffi.Char> file_path,
  mnn_callback_0 callback,
);

/// @brief Create runtime info
/// @param configs Schedule config array
/// @param count Config count
/// @return Runtime info instance
@ffi.Native<
    mnn_runtime_info_t Function(ffi.Pointer<mnn_schedule_config_t>, ffi.Size)>()
external mnn_runtime_info_t mnn_interpreter_create_runtime(
  ffi.Pointer<mnn_schedule_config_t> configs,
  int count,
);

/// @brief Create session with config
/// @param self Interpreter instance
/// @param config Schedule config
/// @param callback Callback function to be called after creation
/// @return Session instance or NULL if failed
@ffi.Native<
    mnn_session_t Function(mnn_interpreter_t,
        ffi.Pointer<mnn_schedule_config_t>, mnn_callback_0)>()
external mnn_session_t mnn_interpreter_create_session(
  mnn_interpreter_t self,
  ffi.Pointer<mnn_schedule_config_t> config,
  mnn_callback_0 callback,
);

/// @brief Create session with runtime info
/// @param self Interpreter instance
/// @param config Schedule config
/// @param runtime Runtime info
/// @param callback Callback function to be called after creation
/// @return Session instance or NULL if failed
@ffi.Native<
    mnn_session_t Function(
        mnn_interpreter_t,
        ffi.Pointer<mnn_schedule_config_t>,
        mnn_runtime_info_t,
        mnn_callback_0)>()
external mnn_session_t mnn_interpreter_create_session_with_runtime(
  mnn_interpreter_t self,
  ffi.Pointer<mnn_schedule_config_t> config,
  mnn_runtime_info_t runtime,
  mnn_callback_0 callback,
);

/// @brief Destroy interpreter instance
/// @param self Interpreter to destroy
@ffi.Native<ffi.Void Function(mnn_interpreter_t)>()
external void mnn_interpreter_destroy(
  mnn_interpreter_t self,
);

/// @brief Get backend type
/// @param self Interpreter instance
/// @param session Session
/// @return Backend type
@ffi.Native<
    mnn_backend_t Function(mnn_interpreter_t, mnn_session_t, mnn_tensor_t)>()
external mnn_backend_t mnn_interpreter_get_backend(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_tensor_t tensor,
);

/// @brief Get model buffer
/// @param self Interpreter instance
/// @param buffer Output parameter to receive pointer to model data
/// @return Size of model data in bytes, or 0 if failed
@ffi.Native<
    ffi.Size Function(mnn_interpreter_t, ffi.Pointer<ffi.Pointer<ffi.Void>>)>()
external int mnn_interpreter_get_model_buffer(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Pointer<ffi.Void>> buffer,
);

/// @brief Get model version
/// @param self Interpreter instance
/// @return Version string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_get_model_version(
  mnn_interpreter_t self,
);

/// @brief Get session info
/// @param self Interpreter instance
/// @param session Session
/// @param info Output parameter for session info
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t, ffi.Int,
        ffi.Pointer<ffi.Void>)>(symbol: 'mnn_interpreter_get_session_info')
external int _mnn_interpreter_get_session_info(
  mnn_interpreter_t self,
  mnn_session_t session,
  int session_info_code,
  ffi.Pointer<ffi.Void> info,
);

ErrorCode mnn_interpreter_get_session_info(
  mnn_interpreter_t self,
  mnn_session_t session,
  int session_info_code,
  ffi.Pointer<ffi.Void> info,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_info(
      self,
      session,
      session_info_code,
      info,
    ));

/// @brief Get input tensor by name
/// @param self Interpreter instance
/// @param session Session
/// @param name Tensor name (NULL for first input)
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        mnn_interpreter_t, mnn_session_t, ffi.Pointer<ffi.Char>)>()
external mnn_tensor_t mnn_interpreter_get_session_input(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Char> name,
);

/// @brief Get all input tensors from session
/// @param self Interpreter instance
/// @param session Session
/// @param tensors Output parameter for tensor array
/// @param count Output parameter for tensor count
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(
        mnn_interpreter_t,
        mnn_session_t,
        ffi.Pointer<ffi.Pointer<mnn_tensor_t>>,
        ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
        ffi.Pointer<ffi.Size>)>(symbol: 'mnn_interpreter_get_session_input_all')
external int _mnn_interpreter_get_session_input_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
);

ErrorCode mnn_interpreter_get_session_input_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_input_all(
      self,
      session,
      tensors,
      names,
      count,
    ));

/// @brief Get output tensor by name
/// @param self Interpreter instance
/// @param session Session
/// @param name Tensor name (NULL for first output)
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        mnn_interpreter_t, mnn_session_t, ffi.Pointer<ffi.Char>)>()
external mnn_tensor_t mnn_interpreter_get_session_output(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Char> name,
);

/// @brief Get all output tensors from session
/// @param self Interpreter instance
/// @param session Session
/// @param tensors Output parameter for tensor array
/// @param count Output parameter for tensor count
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(
            mnn_interpreter_t,
            mnn_session_t,
            ffi.Pointer<ffi.Pointer<mnn_tensor_t>>,
            ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
            ffi.Pointer<ffi.Size>)>(
    symbol: 'mnn_interpreter_get_session_output_all')
external int _mnn_interpreter_get_session_output_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
);

ErrorCode mnn_interpreter_get_session_output_all(
  mnn_interpreter_t self,
  mnn_session_t session,
  ffi.Pointer<ffi.Pointer<mnn_tensor_t>> tensors,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> names,
  ffi.Pointer<ffi.Size> count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_get_session_output_all(
      self,
      session,
      tensors,
      names,
      count,
    ));

/// @brief Release model
/// @param self Interpreter instance
@ffi.Native<ffi.Void Function(mnn_interpreter_t)>()
external void mnn_interpreter_release_model(
  mnn_interpreter_t self,
);

/// @brief Release session
/// @param self Interpreter instance
/// @param session Session to release
/// @param callback Callback function to be called after release
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_release_session')
external int _mnn_interpreter_release_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_release_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_release_session(
      self,
      session,
      callback,
    ));

/// @brief Resize session
/// @param self Interpreter instance
/// @param session Session to resize
/// @param callback Callback function to be called after resize
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_resize_session')
external int _mnn_interpreter_resize_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_resize_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_session(
      self,
      session,
      callback,
    ));

/// @brief Resize tensor
/// @param tensor Tensor to resize
/// @param dims New dimensions array
/// @param dim_count Dimension count
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_tensor_t,
        ffi.Pointer<ffi.Int>, ffi.Int)>(symbol: 'mnn_interpreter_resize_tensor')
external int _mnn_interpreter_resize_tensor(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  ffi.Pointer<ffi.Int> dims,
  int dim_count,
);

ErrorCode mnn_interpreter_resize_tensor(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  ffi.Pointer<ffi.Int> dims,
  int dim_count,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_tensor(
      self,
      tensor,
      dims,
      dim_count,
    ));

@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_tensor_t, ffi.Int, ffi.Int,
        ffi.Int, ffi.Int)>(symbol: 'mnn_interpreter_resize_tensor_1')
external int _mnn_interpreter_resize_tensor_1(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  int batch,
  int channel,
  int height,
  int width,
);

ErrorCode mnn_interpreter_resize_tensor_1(
  mnn_interpreter_t self,
  mnn_tensor_t tensor,
  int batch,
  int channel,
  int height,
  int width,
) =>
    ErrorCode.fromValue(_mnn_interpreter_resize_tensor_1(
      self,
      tensor,
      batch,
      channel,
      height,
      width,
    ));

/// @brief Run session
/// @param self Interpreter instance
/// @param session Session to run
/// @param callback Callback function to be called after run
/// @return Error code
@ffi.Native<
    ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t,
        mnn_callback_0)>(symbol: 'mnn_interpreter_run_session')
external int _mnn_interpreter_run_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
);

ErrorCode mnn_interpreter_run_session(
  mnn_interpreter_t self,
  mnn_session_t session,
  mnn_callback_0 callback,
) =>
    ErrorCode.fromValue(_mnn_interpreter_run_session(
      self,
      session,
      callback,
    ));

/// @brief Set cache file for interpreter
/// @param self Interpreter instance
/// @param cache_file Cache file path
/// @param key_size Key size
@ffi.Native<
    ffi.Void Function(mnn_interpreter_t, ffi.Pointer<ffi.Char>, ffi.Size)>()
external void mnn_interpreter_set_cache_file(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Char> cache_file,
  int key_size,
);

/// @brief Set external file for interpreter
/// @param self Interpreter instance
/// @param file External file path
/// @param flag Flag value
@ffi.Native<
    ffi.Void Function(mnn_interpreter_t, ffi.Pointer<ffi.Char>, ffi.Size)>()
external void mnn_interpreter_set_external_file(
  mnn_interpreter_t self,
  ffi.Pointer<ffi.Char> file,
  int flag,
);

/// @brief Set session hint
/// @param self Interpreter instance
/// @param mode Hint mode
/// @param value Hint value
@ffi.Native<ffi.Void Function(mnn_interpreter_t, ffi.Int, ffi.Int)>()
external void mnn_interpreter_set_session_hint(
  mnn_interpreter_t self,
  int mode,
  int value,
);

/// @brief Set session mode
/// @param self Interpreter instance
/// @param mode Session mode
@ffi.Native<ffi.Void Function(mnn_interpreter_t, ffi.Int)>()
external void mnn_interpreter_set_session_mode(
  mnn_interpreter_t self,
  int mode,
);

/// @brief Update cache file
/// @param self Interpreter instance
/// @param session Session
/// @param flag Flag value
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t, ffi.Int)>(
    symbol: 'mnn_interpreter_update_cache_file')
external int _mnn_interpreter_update_cache_file(
  mnn_interpreter_t self,
  mnn_session_t session,
  int flag,
);

ErrorCode mnn_interpreter_update_cache_file(
  mnn_interpreter_t self,
  mnn_session_t session,
  int flag,
) =>
    ErrorCode.fromValue(_mnn_interpreter_update_cache_file(
      self,
      session,
      flag,
    ));

/// @brief Update session to model
/// @param self Interpreter instance
/// @param session Session
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_interpreter_t, mnn_session_t)>(
    symbol: 'mnn_interpreter_update_session_to_model')
external int _mnn_interpreter_update_session_to_model(
  mnn_interpreter_t self,
  mnn_session_t session,
);

ErrorCode mnn_interpreter_update_session_to_model(
  mnn_interpreter_t self,
  mnn_session_t session,
) =>
    ErrorCode.fromValue(_mnn_interpreter_update_session_to_model(
      self,
      session,
    ));

/// @brief Get uuid from interpreter
/// @param self Interpreter instance
/// @return Uuid string or NULL if failed
@ffi.Native<ffi.Pointer<ffi.Char> Function(mnn_interpreter_t)>(isLeaf: true)
external ffi.Pointer<ffi.Char> mnn_interpreter_uuid(
  mnn_interpreter_t self,
);

/// @brief Destroy runtime info
/// @param runtime Runtime info to destroy
@ffi.Native<ffi.Void Function(mnn_runtime_info_t)>()
external void mnn_runtime_info_destroy(
  mnn_runtime_info_t runtime,
);

/// @brief Get tensor batch
/// @param self Tensor
/// @return Batch
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_batch(
  mnn_tensor_t self,
);

/// @brief Get buffer
/// @param self Tensor
/// @return Buffer pointer
@ffi.Native<ffi.Pointer<halide_buffer_c_t> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<halide_buffer_c_t> mnn_tensor_buffer(
  mnn_tensor_t self,
);

/// @brief Get tensor channel
/// @param self Tensor
/// @return Channel
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_channel(
  mnn_tensor_t self,
);

/// @brief Clone tensor
/// @param src Source tensor
/// @param deep_copy Whether to perform deep copy
/// @return Cloned tensor or NULL if failed
@ffi.Native<mnn_tensor_t Function(mnn_tensor_t, ffi.Bool)>()
external mnn_tensor_t mnn_tensor_clone(
  mnn_tensor_t src,
  bool deep_copy,
);

/// @brief Copy data from host tensor
/// @param self Target tensor
/// @param host_tensor Source tensor
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, mnn_tensor_t)>(
    symbol: 'mnn_tensor_copy_from_host')
external int _mnn_tensor_copy_from_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
);

ErrorCode mnn_tensor_copy_from_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
) =>
    ErrorCode.fromValue(_mnn_tensor_copy_from_host(
      self,
      host_tensor,
    ));

/// @brief Copy data to host tensor
/// @param self Source tensor
/// @param host_tensor Target tensor
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, mnn_tensor_t)>(
    symbol: 'mnn_tensor_copy_to_host')
external int _mnn_tensor_copy_to_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
);

ErrorCode mnn_tensor_copy_to_host(
  mnn_tensor_t self,
  mnn_tensor_t host_tensor,
) =>
    ErrorCode.fromValue(_mnn_tensor_copy_to_host(
      self,
      host_tensor,
    ));

/// @brief Create tensor with dimension size and type
/// @param dim_size Dimension size
/// @param type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<mnn_tensor_t Function(ffi.Int, ffi.UnsignedInt)>(
    symbol: 'mnn_tensor_create')
external mnn_tensor_t _mnn_tensor_create(
  int dim_size,
  int type,
);

mnn_tensor_t mnn_tensor_create(
  int dim_size,
  DimensionType type,
) =>
    _mnn_tensor_create(
      dim_size,
      type.value,
    );

/// @brief Create device tensor
/// @param shape Tensor shape array
/// @param shape_size Shape array size
/// @param type Data type
/// @param dim_type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(ffi.Pointer<ffi.Int>, ffi.Int, halide_type_c_t,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_create_device')
external mnn_tensor_t _mnn_tensor_create_device(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_c_t type,
  int dim_type,
);

mnn_tensor_t mnn_tensor_create_device(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_c_t type,
  DimensionType dim_type,
) =>
    _mnn_tensor_create_device(
      shape,
      shape_size,
      type,
      dim_type.value,
    );

/// @brief Create tensor with same shape as given tensor
/// @param self Shape provider
/// @param type Dimension type
/// @param alloc_memory Whether allocate memory
/// @return Tensor instance or NULL if failed
@ffi.Native<mnn_tensor_t Function(mnn_tensor_t, ffi.UnsignedInt, ffi.Bool)>(
    symbol: 'mnn_tensor_create_from_tensor')
external mnn_tensor_t _mnn_tensor_create_from_tensor(
  mnn_tensor_t self,
  int type,
  bool alloc_memory,
);

mnn_tensor_t mnn_tensor_create_from_tensor(
  mnn_tensor_t self,
  DimensionType type,
  bool alloc_memory,
) =>
    _mnn_tensor_create_from_tensor(
      self,
      type.value,
      alloc_memory,
    );

/// @brief Create tensor with data
/// @param shape Tensor shape array
/// @param shape_size Shape array size
/// @param type Data type
/// @param data Data pointer
/// @param dim_type Dimension type
/// @return Tensor instance or NULL if failed
@ffi.Native<
    mnn_tensor_t Function(
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        halide_type_c_t,
        ffi.Pointer<ffi.Void>,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_create_with_data')
external mnn_tensor_t _mnn_tensor_create_with_data(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_c_t type,
  ffi.Pointer<ffi.Void> data,
  int dim_type,
);

mnn_tensor_t mnn_tensor_create_with_data(
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
  halide_type_c_t type,
  ffi.Pointer<ffi.Void> data,
  DimensionType dim_type,
) =>
    _mnn_tensor_create_with_data(
      shape,
      shape_size,
      type,
      data,
      dim_type.value,
    );

/// @brief Destroy tensor
/// @param tensor Tensor to destroy
@ffi.Native<ffi.Void Function(mnn_tensor_t)>(isLeaf: true)
external void mnn_tensor_destroy(
  mnn_tensor_t tensor,
);

/// @brief Get device ID
/// @param self Tensor
/// @return Device ID
@ffi.Native<ffi.Uint64 Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_device_id(
  mnn_tensor_t self,
);

/// @brief Get tensor dimensions
/// @param self Tensor
/// @return Dimension count
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_dimensions(
  mnn_tensor_t self,
);

/// @brief Get tensor element count
/// @param self Tensor
/// @return Element count
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_element_size(
  mnn_tensor_t self,
);

/// @brief Get dimension type
/// @param self Tensor
/// @return Dimension type
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t)>(
    symbol: 'mnn_tensor_get_dimension_type', isLeaf: true)
external int _mnn_tensor_get_dimension_type(
  mnn_tensor_t self,
);

DimensionType mnn_tensor_get_dimension_type(
  mnn_tensor_t self,
) =>
    DimensionType.fromValue(_mnn_tensor_get_dimension_type(
      self,
    ));

/// @brief Get handle data type
/// @param self Tensor
/// @return Handle data type
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t)>(
    symbol: 'mnn_tensor_get_handle_data_type', isLeaf: true)
external int _mnn_tensor_get_handle_data_type(
  mnn_tensor_t self,
);

HandleDataType mnn_tensor_get_handle_data_type(
  mnn_tensor_t self,
) =>
    HandleDataType.fromValue(_mnn_tensor_get_handle_data_type(
      self,
    ));

/// @brief Get data type
/// @param self Tensor
/// @return Data type
@ffi.Native<ffi.Pointer<halide_type_c_t> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<halide_type_c_t> mnn_tensor_get_type(
  mnn_tensor_t self,
);

/// @brief Get tensor height
/// @param self Tensor
/// @return Height
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_height(
  mnn_tensor_t self,
);

/// @brief Get host data pointer
/// @param self Tensor
/// @return Data pointer or NULL
@ffi.Native<ffi.Pointer<ffi.Void> Function(mnn_tensor_t)>(isLeaf: true)
external ffi.Pointer<ffi.Void> mnn_tensor_host(
  mnn_tensor_t self,
);

/// @brief Get tensor length
/// @param self Tensor
/// @param index Dimension index
/// @return Length
@ffi.Native<ffi.Int Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external int mnn_tensor_length(
  mnn_tensor_t self,
  int index,
);

/// @brief Map tensor for access
/// @param self Tensor
/// @param mtype Map type
/// @param dtype Dimension type
/// @return Mapped pointer or NULL
@ffi.Native<
    ffi.Pointer<ffi.Void> Function(mnn_tensor_t, ffi.UnsignedInt,
        ffi.UnsignedInt)>(symbol: 'mnn_tensor_map', isLeaf: true)
external ffi.Pointer<ffi.Void> _mnn_tensor_map(
  mnn_tensor_t self,
  int mtype,
  int dtype,
);

ffi.Pointer<ffi.Void> mnn_tensor_map(
  mnn_tensor_t self,
  MapType mtype,
  DimensionType dtype,
) =>
    _mnn_tensor_map(
      self,
      mtype.value,
      dtype.value,
    );

@ffi.Native<ffi.Void Function(mnn_tensor_t)>()
external void mnn_tensor_print(
  mnn_tensor_t self,
);

@ffi.Native<ffi.Void Function(mnn_tensor_t)>()
external void mnn_tensor_print_shape(
  mnn_tensor_t self,
);

/// @brief Set device pointer
/// @param self Tensor
/// @param device_ptr Device pointer
/// @param memory_type Memory type
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_tensor_t, ffi.Pointer<ffi.Void>, ffi.Int)>(
    symbol: 'mnn_tensor_set_device_ptr', isLeaf: true)
external int _mnn_tensor_set_device_ptr(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Void> device_ptr,
  int memory_type,
);

ErrorCode mnn_tensor_set_device_ptr(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Void> device_ptr,
  int memory_type,
) =>
    ErrorCode.fromValue(_mnn_tensor_set_device_ptr(
      self,
      device_ptr,
      memory_type,
    ));

@ffi.Native<
    ffi.UnsignedInt Function(
        mnn_tensor_t,
        ffi.Int,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Int,
        ffi.Int)>(symbol: 'mnn_tensor_set_image_f32', isLeaf: true)
external int _mnn_tensor_set_image_f32(
  mnn_tensor_t self,
  int index,
  ffi.Pointer<ffi.Float> data,
  int width,
  int height,
  int channel,
);

ErrorCode mnn_tensor_set_image_f32(
  mnn_tensor_t self,
  int index,
  ffi.Pointer<ffi.Float> data,
  int width,
  int height,
  int channel,
) =>
    ErrorCode.fromValue(_mnn_tensor_set_image_f32(
      self,
      index,
      data,
      width,
      height,
      channel,
    ));

/// @brief Set tensor length
/// @param self Tensor
/// @param index Dimension index
/// @param length Length value
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_length(
  mnn_tensor_t self,
  int index,
  int length,
);

/// @brief Set tensor stride
/// @param self Tensor
/// @param index Dimension index
/// @param stride Stride value
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_stride(
  mnn_tensor_t self,
  int index,
  int stride,
);

/// @brief Set data type
/// @param self Tensor
/// @param type Data type
@ffi.Native<ffi.Void Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external void mnn_tensor_set_type(
  mnn_tensor_t self,
  int type,
);

/// @brief Get tensor shape
/// @param self Tensor
/// @param shape Output shape array (must be pre-allocated)
/// @param shape_size Shape array size
/// @return Error code
@ffi.Native<
        ffi.UnsignedInt Function(mnn_tensor_t, ffi.Pointer<ffi.Int>, ffi.Int)>(
    symbol: 'mnn_tensor_shape', isLeaf: true)
external int _mnn_tensor_shape(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
);

ErrorCode mnn_tensor_shape(
  mnn_tensor_t self,
  ffi.Pointer<ffi.Int> shape,
  int shape_size,
) =>
    ErrorCode.fromValue(_mnn_tensor_shape(
      self,
      shape,
      shape_size,
    ));

/// @brief Get tensor data size in bytes
/// @param self Tensor
/// @return Size in bytes
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_size(
  mnn_tensor_t self,
);

/// @brief Get tensor stride
/// @param self Tensor
/// @param index Dimension index
/// @return Stride
@ffi.Native<ffi.Int Function(mnn_tensor_t, ffi.Int)>(isLeaf: true)
external int mnn_tensor_stride(
  mnn_tensor_t self,
  int index,
);

/// @brief Unmap tensor
/// @param self Tensor
/// @param mtype Map type
/// @param dtype Dimension type
/// @param map_ptr Mapped pointer
@ffi.Native<
    ffi.Void Function(mnn_tensor_t, ffi.UnsignedInt, ffi.UnsignedInt,
        ffi.Pointer<ffi.Void>)>(symbol: 'mnn_tensor_unmap', isLeaf: true)
external void _mnn_tensor_unmap(
  mnn_tensor_t self,
  int mtype,
  int dtype,
  ffi.Pointer<ffi.Void> map_ptr,
);

void mnn_tensor_unmap(
  mnn_tensor_t self,
  MapType mtype,
  DimensionType dtype,
  ffi.Pointer<ffi.Void> map_ptr,
) =>
    _mnn_tensor_unmap(
      self,
      mtype.value,
      dtype.value,
      map_ptr,
    );

/// @brief Get tensor shape in bytes (unsigned)
/// @param self Tensor
/// @return Size in bytes
@ffi.Native<ffi.Size Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_usize(
  mnn_tensor_t self,
);

/// @brief Wait for tensor ready
/// @param self Tensor
/// @param mtype Map type
/// @param finish Whether wait for finish
/// @return Error code
@ffi.Native<ffi.UnsignedInt Function(mnn_tensor_t, ffi.UnsignedInt, ffi.Bool)>(
    symbol: 'mnn_tensor_wait')
external int _mnn_tensor_wait(
  mnn_tensor_t self,
  int mtype,
  bool finish,
);

ErrorCode mnn_tensor_wait(
  mnn_tensor_t self,
  MapType mtype,
  bool finish,
) =>
    ErrorCode.fromValue(_mnn_tensor_wait(
      self,
      mtype.value,
      finish,
    ));

/// @brief Get tensor width
/// @param self Tensor
/// @return Width
@ffi.Native<ffi.Int Function(mnn_tensor_t)>(isLeaf: true)
external int mnn_tensor_width(
  mnn_tensor_t self,
);

/// @brief Creates a new timer instance
/// @return Pointer to the newly created timer
@ffi.Native<mnn_timer_t Function()>()
external mnn_timer_t mnn_timer_create();

/// @brief Gets the current time value from timer
/// @param timer Timer instance to query
/// @return Current time value
@ffi.Native<ffi.Uint64 Function(mnn_timer_t)>()
external int mnn_timer_current(
  mnn_timer_t timer,
);

/// @brief Destroys a timer instance
/// @param timer Timer instance to destroy
@ffi.Native<ffi.Void Function(mnn_timer_t)>()
external void mnn_timer_destroy(
  mnn_timer_t timer,
);

/// @brief Gets the duration in microseconds since last reset
/// @param timer Timer instance to query
/// @return Duration in microseconds
@ffi.Native<ffi.Uint64 Function(mnn_timer_t)>()
external int mnn_timer_duration_us(
  mnn_timer_t timer,
);

/// @brief Resets the timer to current time
/// @param timer Timer instance to reset
@ffi.Native<ffi.Void Function(mnn_timer_t)>()
external void mnn_timer_reset(
  mnn_timer_t timer,
);

/// indicate whether we should process iphone images back to canonical format,
/// or just pass them through "as-is"
@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_convert_iphone_png_to_rgb(
  int flag_true_if_should_convert,
);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_convert_iphone_png_to_rgb_thread(
  int flag_true_if_should_convert,
);

/// get a VERY brief reason for failure
/// on most compilers (and ALL modern mainstream compilers) this is threadsafe
@ffi.Native<ffi.Pointer<ffi.Char> Function()>()
external ffi.Pointer<ffi.Char> stbi_failure_reason();

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void stbi_hdr_to_ldr_gamma(
  double gamma,
);

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void stbi_hdr_to_ldr_scale(
  double scale,
);

/// free the loaded image -- this is just free()
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
external void stbi_image_free(
  ffi.Pointer<ffi.Void> retval_from_stbi_load,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>()
external int stbi_info(
  ffi.Pointer<ffi.Char> filename,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> comp,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<stbi_io_callbacks>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>()
external int stbi_info_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> comp,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>()
external int stbi_info_from_file(
  ffi.Pointer<FILE> f,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> comp,
);

/// get image dimensions & components without fully decoding
@ffi.Native<
    ffi.Int Function(ffi.Pointer<stbi_uc>, ffi.Int, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>()
external int stbi_info_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> comp,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int stbi_is_16_bit(
  ffi.Pointer<ffi.Char> filename,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<stbi_io_callbacks>, ffi.Pointer<ffi.Void>)>()
external int stbi_is_16_bit_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<FILE>)>()
external int stbi_is_16_bit_from_file(
  ffi.Pointer<FILE> f,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<stbi_uc>, ffi.Int)>()
external int stbi_is_16_bit_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>)>()
external int stbi_is_hdr(
  ffi.Pointer<ffi.Char> filename,
);

/// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
@ffi.Native<
    ffi.Int Function(ffi.Pointer<stbi_io_callbacks>, ffi.Pointer<ffi.Void>)>()
external int stbi_is_hdr_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<FILE>)>()
external int stbi_is_hdr_from_file(
  ffi.Pointer<FILE> f,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<stbi_uc>, ffi.Int)>()
external int stbi_is_hdr_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
);

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void stbi_ldr_to_hdr_gamma(
  double gamma,
);

@ffi.Native<ffi.Void Function(ffi.Float)>()
external void stbi_ldr_to_hdr_scale(
  double scale,
);

@ffi.Native<
    ffi.Pointer<stbi_uc> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<stbi_uc> stbi_load(
  ffi.Pointer<ffi.Char> filename,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_us> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<stbi_us> stbi_load_16(
  ffi.Pointer<ffi.Char> filename,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_us> Function(
        ffi.Pointer<stbi_io_callbacks>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<stbi_us> stbi_load_16_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

/// /////////////////////////////////
///
/// 16-bits-per-channel interface
@ffi.Native<
    ffi.Pointer<stbi_us> Function(
        ffi.Pointer<stbi_uc>,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<stbi_us> stbi_load_16_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_uc> Function(
        ffi.Pointer<stbi_io_callbacks>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<stbi_uc> stbi_load_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_uc> Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<stbi_uc> stbi_load_from_file(
  ffi.Pointer<FILE> f,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_us> Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<stbi_us> stbi_load_from_file_16(
  ffi.Pointer<FILE> f,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

/// /////////////////////////////////
///
/// 8-bits-per-channel interface
@ffi.Native<
    ffi.Pointer<stbi_uc> Function(
        ffi.Pointer<stbi_uc>,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<stbi_uc> stbi_load_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<stbi_uc> Function(
        ffi.Pointer<stbi_uc>,
        ffi.Int,
        ffi.Pointer<ffi.Pointer<ffi.Int>>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<stbi_uc> stbi_load_gif_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
  ffi.Pointer<ffi.Pointer<ffi.Int>> delays,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> z,
  ffi.Pointer<ffi.Int> comp,
  int req_comp,
);

@ffi.Native<
    ffi.Pointer<ffi.Float> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<ffi.Float> stbi_loadf(
  ffi.Pointer<ffi.Char> filename,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<ffi.Float> Function(
        ffi.Pointer<stbi_io_callbacks>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<ffi.Float> stbi_loadf_from_callbacks(
  ffi.Pointer<stbi_io_callbacks> clbk,
  ffi.Pointer<ffi.Void> user,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<ffi.Float> Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<ffi.Float> stbi_loadf_from_file(
  ffi.Pointer<FILE> f,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

@ffi.Native<
    ffi.Pointer<ffi.Float> Function(
        ffi.Pointer<stbi_uc>,
        ffi.Int,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int)>()
external ffi.Pointer<ffi.Float> stbi_loadf_from_memory(
  ffi.Pointer<stbi_uc> buffer,
  int len,
  ffi.Pointer<ffi.Int> x,
  ffi.Pointer<ffi.Int> y,
  ffi.Pointer<ffi.Int> channels_in_file,
  int desired_channels,
);

/// flip the image vertically, so the first pixel in the output array is the bottom left
@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_set_flip_vertically_on_load(
  int flag_true_if_should_flip,
);

@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_set_flip_vertically_on_load_thread(
  int flag_true_if_should_flip,
);

/// for image formats that explicitly notate that they have premultiplied alpha,
/// we just return the colors as stored in the file. set this flag to force
/// unpremultiplication. results are undefined if the unpremultiply overflow.
@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_set_unpremultiply_on_load(
  int flag_true_if_should_unpremultiply,
);

/// as above, but only applies to images loaded on the thread that calls the function
/// this function is only available if your compiler supports thread-local variables;
/// calling it will fail to link if your compiler doesn't
@ffi.Native<ffi.Void Function(ffi.Int)>()
external void stbi_set_unpremultiply_on_load_thread(
  int flag_true_if_should_unpremultiply,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>()
external int stbi_zlib_decode_buffer(
  ffi.Pointer<ffi.Char> obuffer,
  int olen,
  ffi.Pointer<ffi.Char> ibuffer,
  int ilen,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Int>)>()
external ffi.Pointer<ffi.Char> stbi_zlib_decode_malloc(
  ffi.Pointer<ffi.Char> buffer,
  int len,
  ffi.Pointer<ffi.Int> outlen,
);

/// ZLIB client - used by PNG, available for other purposes
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int, ffi.Pointer<ffi.Int>)>()
external ffi.Pointer<ffi.Char> stbi_zlib_decode_malloc_guesssize(
  ffi.Pointer<ffi.Char> buffer,
  int len,
  int initial_size,
  ffi.Pointer<ffi.Int> outlen,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int,
        ffi.Pointer<ffi.Int>, ffi.Int)>()
external ffi.Pointer<ffi.Char> stbi_zlib_decode_malloc_guesssize_headerflag(
  ffi.Pointer<ffi.Char> buffer,
  int len,
  int initial_size,
  ffi.Pointer<ffi.Int> outlen,
  int parse_header,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>()
external int stbi_zlib_decode_noheader_buffer(
  ffi.Pointer<ffi.Char> obuffer,
  int olen,
  ffi.Pointer<ffi.Char> ibuffer,
  int ilen,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Int>)>()
external ffi.Pointer<ffi.Char> stbi_zlib_decode_noheader_malloc(
  ffi.Pointer<ffi.Char> buffer,
  int len,
  ffi.Pointer<ffi.Int> outlen,
);

const addresses = _SymbolAddresses();

class _SymbolAddresses {
  const _SymbolAddresses();
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_auto_time_t)>>
      get mnn_auto_time_destroy =>
          ffi.Native.addressOf(self.mnn_auto_time_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_cv_image_process_t)>>
      get mnn_cv_image_process_destroy =>
          ffi.Native.addressOf(self.mnn_cv_image_process_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_cv_matrix_t)>>
      get mnn_cv_matrix_destroy =>
          ffi.Native.addressOf(self.mnn_cv_matrix_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_interpreter_t)>>
      get mnn_interpreter_destroy =>
          ffi.Native.addressOf(self.mnn_interpreter_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_runtime_info_t)>>
      get mnn_runtime_info_destroy =>
          ffi.Native.addressOf(self.mnn_runtime_info_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_tensor_t)>>
      get mnn_tensor_destroy => ffi.Native.addressOf(self.mnn_tensor_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(mnn_timer_t)>>
      get mnn_timer_destroy => ffi.Native.addressOf(self.mnn_timer_destroy);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get stbi_image_free => ffi.Native.addressOf(self.stbi_image_free);
}

enum DimensionType {
  MNN_TENSORFLOW(0),
  MNN_CAFFE(1),
  MNN_CAFFE_C4(2);

  final int value;
  const DimensionType(this.value);

  static DimensionType fromValue(int value) => switch (value) {
        0 => MNN_TENSORFLOW,
        1 => MNN_CAFFE,
        2 => MNN_CAFFE_C4,
        _ => throw ArgumentError('Unknown value for DimensionType: $value'),
      };
}

/// Error code enum
enum ErrorCode {
  NO_ERROR(0),
  OUT_OF_MEMORY(1),
  NOT_SUPPORT(2),
  COMPUTE_SIZE_ERROR(3),
  NO_EXECUTION(4),
  INVALID_VALUE(5),

  /// User error
  INPUT_DATA_ERROR(10),
  CALL_BACK_STOP(11),

  /// Op Resize Error
  TENSOR_NOT_SUPPORT(20),
  TENSOR_NEED_DIVIDE(21),

  /// File error
  FILE_CREATE_FAILED(30),
  FILE_REMOVE_FAILED(31),
  FILE_OPEN_FAILED(32),
  FILE_CLOSE_FAILED(33),
  FILE_RESIZE_FAILED(34),
  FILE_SEEK_FAILED(35),
  FILE_NOT_EXIST(36),
  FILE_UNMAP_FAILED(37),

  /// custom
  BOOL_TRUE(100),
  BOOL_FALSE(101),
  UNKNOWN_ERROR(102),
  MNN_INVALID_PTR(103);

  final int value;
  const ErrorCode(this.value);

  static ErrorCode fromValue(int value) => switch (value) {
        0 => NO_ERROR,
        1 => OUT_OF_MEMORY,
        2 => NOT_SUPPORT,
        3 => COMPUTE_SIZE_ERROR,
        4 => NO_EXECUTION,
        5 => INVALID_VALUE,
        10 => INPUT_DATA_ERROR,
        11 => CALL_BACK_STOP,
        20 => TENSOR_NOT_SUPPORT,
        21 => TENSOR_NEED_DIVIDE,
        30 => FILE_CREATE_FAILED,
        31 => FILE_REMOVE_FAILED,
        32 => FILE_OPEN_FAILED,
        33 => FILE_CLOSE_FAILED,
        34 => FILE_RESIZE_FAILED,
        35 => FILE_SEEK_FAILED,
        36 => FILE_NOT_EXIST,
        37 => FILE_UNMAP_FAILED,
        100 => BOOL_TRUE,
        101 => BOOL_FALSE,
        102 => UNKNOWN_ERROR,
        103 => MNN_INVALID_PTR,
        _ => throw ArgumentError('Unknown value for ErrorCode: $value'),
      };
}

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
typedef FILE = __sFILE;

/// Types in the halide type system. They can be ints, unsigned ints,
/// or floats (of various bit-widths), or a handle (which is always 64-bits).
/// Note that the int/uint/float values do not imply a specific bit width
/// (the bit width is expected to be encoded in a separate value).
enum HalideTypeCode {
  /// !< signed integers
  halide_type_int(0),

  /// !< unsigned integers
  halide_type_uint(1),

  /// !< IEEE floating point numbers
  halide_type_float(2),

  /// !< opaque pointer type (void *)
  halide_type_handle(3),

  /// !< floating point numbers in the bfloat format
  halide_type_bfloat(4);

  final int value;
  const HalideTypeCode(this.value);

  static HalideTypeCode fromValue(int value) => switch (value) {
        0 => halide_type_int,
        1 => halide_type_uint,
        2 => halide_type_float,
        3 => halide_type_handle,
        4 => halide_type_bfloat,
        _ => throw ArgumentError('Unknown value for HalideTypeCode: $value'),
      };
}

enum HandleDataType {
  MNN_HANDLE_NONE(0),
  MNN_HANDLE_STRING(1);

  final int value;
  const HandleDataType(this.value);

  static HandleDataType fromValue(int value) => switch (value) {
        0 => MNN_HANDLE_NONE,
        1 => MNN_HANDLE_STRING,
        _ => throw ArgumentError('Unknown value for HandleDataType: $value'),
      };
}

enum MapType {
  MNN_MAP_TENSOR_WRITE(0),
  MNN_MAP_TENSOR_READ(1);

  final int value;
  const MapType(this.value);

  static MapType fromValue(int value) => switch (value) {
        0 => MNN_MAP_TENSOR_WRITE,
        1 => MNN_MAP_TENSOR_READ,
        _ => throw ArgumentError('Unknown value for MapType: $value'),
      };
}

const int STBI_VERSION = 1;

const int STBI_default = 0;

const int STBI_default$1 = 0;

const int STBI_grey = 1;

const int STBI_grey$1 = 1;

const int STBI_grey_alpha = 2;

const int STBI_grey_alpha$1 = 2;

const int STBI_rgb = 3;

const int STBI_rgb$1 = 3;

const int STBI_rgb_alpha = 4;

const int STBI_rgb_alpha$1 = 4;

final class UnnamedUnion1 extends ffi.Union {
  external ffi.Pointer<ffi.Void> sharedContext;

  @ffi.Size()
  external int flags;
}

/// CPU:number of threads in parallel , Or GPU: mode setting
final class UnnamedUnion2 extends ffi.Union {
  @ffi.Int()
  external int num_thread;

  @ffi.Int()
  external int mode;
}

typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
final class __sFILE extends ffi.Struct {
  /// current position in (some) buffer
  external ffi.Pointer<ffi.UnsignedChar> _p;

  /// read space left for getc()
  @ffi.Int()
  external int _r;

  /// write space left for putc()
  @ffi.Int()
  external int _w;

  /// flags, below; this FILE is free if 0
  @ffi.Short()
  external int _flags;

  /// fileno, if Unix descriptor, else -1
  @ffi.Short()
  external int _file;

  /// the buffer (at least 1 byte, if !NULL)
  external __sbuf _bf;

  /// 0 or -_bf._size, for inline putc
  @ffi.Int()
  external int _lbfsize;

  /// cookie passed to io functions
  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  /// ungetc buffer
  external __sbuf _ub;

  /// additions to FILE to not break ABI
  external ffi.Pointer<__sFILEX> _extra;

  /// saved _r when _r is counting ungetc data
  @ffi.Int()
  external int _ur;

  /// guarantee an ungetc() buffer
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  /// guarantee a getc() buffer
  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  /// buffer for fgetln()
  external __sbuf _lb;

  /// stat.st_blksize (may be != _bf._size)
  @ffi.Int()
  external int _blksize;

  /// current lseek offset (see WARNING)
  @fpos_t()
  external int _offset;
}

/// hold a buncha junk that would grow the ABI
final class __sFILEX extends ffi.Opaque {}

/// stdio buffers
final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

typedef fpos_t = __darwin_off_t;

/// The raw representation of an image passed around by generated
/// Halide code. It includes some stuff to track whether the image is
/// not actually in main memory, but instead on a device (like a
/// GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>.
final class halide_buffer_c_t extends ffi.Struct {
  /// A device-handle for e.g. GPU memory used to back this buffer.
  @ffi.Uint64()
  external int device;

  /// The interface used to interpret the above handle.
  external ffi.Pointer<halide_device_interface_t> device_interface;

  /// A pointer to the start of the data in main memory. In terms of
  /// the Halide coordinate system, this is the address of the min
  /// coordinates (defined below).
  external ffi.Pointer<ffi.Uint8> host;

  /// flags with various meanings.
  @ffi.Uint64()
  external int flags;

  /// The type of each buffer element.
  external halide_type_c_t type;

  /// The dimensionality of the buffer.
  @ffi.Int32()
  external int dimensions;

  /// The shape of the buffer. Halide does not own this array - you
  /// must manage the memory for it yourself.
  external ffi.Pointer<halide_dimension_t> dim;

  /// Pads the buffer up to a multiple of 8 bytes
  external ffi.Pointer<ffi.Void> padding;
}

enum halide_buffer_flags {
  halide_buffer_flag_host_dirty(1),
  halide_buffer_flag_device_dirty(2);

  final int value;
  const halide_buffer_flags(this.value);

  static halide_buffer_flags fromValue(int value) => switch (value) {
        1 => halide_buffer_flag_host_dirty,
        2 => halide_buffer_flag_device_dirty,
        _ =>
          throw ArgumentError('Unknown value for halide_buffer_flags: $value'),
      };
}

/// The raw representation of an image passed around by generated
/// Halide code. It includes some stuff to track whether the image is
/// not actually in main memory, but instead on a device (like a
/// GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>.
final class halide_buffer_t extends ffi.Struct {
  /// A device-handle for e.g. GPU memory used to back this buffer.
  @ffi.Uint64()
  external int device;

  /// The interface used to interpret the above handle.
  external ffi.Pointer<halide_device_interface_t> device_interface;

  /// A pointer to the start of the data in main memory. In terms of
  /// the Halide coordinate system, this is the address of the min
  /// coordinates (defined below).
  external ffi.Pointer<ffi.Uint8> host;

  /// flags with various meanings.
  @ffi.Uint64()
  external int flags;

  /// The type of each buffer element.
  external halide_type_t type;

  /// The dimensionality of the buffer.
  @ffi.Int32()
  external int dimensions;

  /// The shape of the buffer. Halide does not own this array - you
  /// must manage the memory for it yourself.
  external ffi.Pointer<halide_dimension_t> dim;

  /// Pads the buffer up to a multiple of 8 bytes
  external ffi.Pointer<ffi.Void> padding;
}

/// An opaque struct containing per-GPU API implementations of the
/// device functions.
final class halide_device_interface_impl_t extends ffi.Opaque {}

/// Each GPU API provides a halide_device_interface_t struct pointing
/// to the code that manages device allocations. You can access these
/// functions directly from the struct member function pointers, or by
/// calling the functions declared below. Note that the global
/// functions are not available when using Halide as a JIT compiler.
/// If you are using raw halide_buffer_t in that context you must use
/// the function pointers in the device_interface struct.
///
/// The function pointers below are currently the same for every GPU
/// API; only the impl field varies. These top-level functions do the
/// bookkeeping that is common across all GPU APIs, and then dispatch
/// to more API-specific functions via another set of function pointers
/// hidden inside the impl field.
final class halide_device_interface_t extends ffi.Struct {
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_malloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_sync;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_release;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> copy_to_host;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      copy_to_device;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      device_and_host_malloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_and_host_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> src,
              ffi.Pointer<halide_device_interface_t> dst_device_interface,
              ffi.Pointer<halide_buffer_t> dst)>> buffer_copy;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> src,
              ffi.Pointer<halide_buffer_t> dst)>> device_crop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> device_release_crop;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Void> user_context,
                  ffi.Pointer<halide_buffer_t> buf,
                  ffi.Uint64 handle,
                  ffi.Pointer<halide_device_interface_t> device_interface)>>
      wrap_native;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user_context,
              ffi.Pointer<halide_buffer_t> buf)>> detach_native;

  external ffi.Pointer<halide_device_interface_impl_t> impl;
}

final class halide_dimension_t extends ffi.Struct {
  @ffi.Int32()
  external int min;

  @ffi.Int32()
  external int extent;

  @ffi.Int32()
  external int stride;

  /// Per-dimension flags. None are defined yet (This is reserved for future use).
  @ffi.Uint32()
  external int flags;
}

final class halide_type_c_t extends ffi.Struct {
  @ffi.Uint8()
  external int code;

  @ffi.Uint8()
  external int bits;

  @ffi.Uint16()
  external int lanes;
}

/// A runtime tag for a type in the halide type system. Can be ints,
/// unsigned ints, or floats of various bit-widths (the 'bits'
/// field). Can also be vectors of the same (by setting the 'lanes'
/// field to something larger than one). This struct should be
/// exactly 32-bits in size.
final class halide_type_t extends ffi.Struct {
  /// halide_type_code_t
  @ffi.UnsignedInt()
  external int codeAsInt;

  HalideTypeCode get code => HalideTypeCode.fromValue(codeAsInt);

  /// The number of bits of precision of a single scalar value of this type.
  @ffi.Uint8()
  external int bits;

  /// How many elements in a vector. This is 1 for scalar types.
  @ffi.Uint16()
  external int lanes;
}

typedef mnn_auto_time_t = ffi.Pointer<ffi.Void>;

final class mnn_backend_config_t extends ffi.Struct {
  /// mnn_memory_mode memory;
  @ffi.Int()
  external int memory;

  /// mnn_power_mode power;
  @ffi.Int()
  external int power;

  /// mnn_precision_mode precision;
  @ffi.Int()
  external int precision;

  external UnnamedUnion1 unnamed;
}

typedef mnn_backend_t = ffi.Pointer<ffi.Void>;
typedef mnn_callback_0
    = ffi.Pointer<ffi.NativeFunction<mnn_callback_0Function>>;
typedef mnn_callback_0Function = ffi.Void Function();
typedef Dartmnn_callback_0Function = void Function();
typedef mnn_cv_image_process_t = ffi.Pointer<ffi.Void>;
typedef mnn_cv_matrix_t = ffi.Pointer<ffi.Void>;

final class mnn_cv_point_t extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

final class mnn_cv_rect_t extends ffi.Struct {
  @ffi.Float()
  external double left;

  @ffi.Float()
  external double top;

  @ffi.Float()
  external double right;

  @ffi.Float()
  external double bottom;
}

/// Forward type enum */
/// // typedef mnn_forward_type mnn_forward_type_t;
typedef mnn_forward_type_t = ffi.Int;
typedef Dartmnn_forward_type_t = int;

final class mnn_image_process_config_t extends ffi.Struct {
  /// data filter
  @ffi.Int()
  external int filterType;

  /// format of source data
  @ffi.Int()
  external int sourceFormat;

  /// format of destination data
  @ffi.Int()
  external int destFormat;

  /// Only valid if the dest type is float
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> mean;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Float> normal;

  /// edge wrapper
  @ffi.Int()
  external int wrap;
}

typedef mnn_interpreter_t = ffi.Pointer<ffi.Void>;
typedef mnn_runtime_info_t = ffi.Pointer<ffi.Void>;

/// Schedule config structure
final class mnn_schedule_config_t extends ffi.Struct {
  @mnn_forward_type_t()
  external int type;

  /// CPU:number of threads in parallel , Or GPU: mode setting
  external UnnamedUnion2 unnamed;

  @mnn_forward_type_t()
  external int backupType;

  external ffi.Pointer<mnn_backend_config_t> backend_config;
}

typedef mnn_session_t = ffi.Pointer<ffi.Void>;

enum mnn_tensor_dtype {
  MNN_T_D_TYPE_F32_F64(0),
  MNN_T_D_TYPE_BF16(1),
  MNN_T_D_TYPE_QI32_I32_BOOL_I64(2),
  MNN_T_D_TYPE_QI8_I8(3),
  MNN_T_D_TYPE_QU8_U8(4),
  MNN_T_D_TYPE_QU16_U16(5),
  MNN_T_D_TYPE_QI16_I16(6);

  final int value;
  const mnn_tensor_dtype(this.value);

  static mnn_tensor_dtype fromValue(int value) => switch (value) {
        0 => MNN_T_D_TYPE_F32_F64,
        1 => MNN_T_D_TYPE_BF16,
        2 => MNN_T_D_TYPE_QI32_I32_BOOL_I64,
        3 => MNN_T_D_TYPE_QI8_I8,
        4 => MNN_T_D_TYPE_QU8_U8,
        5 => MNN_T_D_TYPE_QU16_U16,
        6 => MNN_T_D_TYPE_QI16_I16,
        _ => throw ArgumentError('Unknown value for mnn_tensor_dtype: $value'),
      };
}

typedef mnn_tensor_t = ffi.Pointer<ffi.Void>;
typedef mnn_timer_t = ffi.Pointer<ffi.Void>;

/// load image by filename, open file, or memory buffer
final class stbi_io_callbacks extends ffi.Struct {
  /// fill 'data' with 'size' bytes.  return number of bytes actually read
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> user,
              ffi.Pointer<ffi.Char> data, ffi.Int size)>> read;

  /// skip the next 'n' bytes, or 'unget' the last -n bytes if negative
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> user, ffi.Int n)>> skip;

  /// returns nonzero if we are at end of file/data
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> user)>>
      eof;
}

typedef stbi_uc = ffi.UnsignedChar;
typedef Dartstbi_uc = int;
typedef stbi_us = ffi.UnsignedShort;
typedef Dartstbi_us = int;
